# 实验四：调和级数求和顺序与舍入误差实验报告

## 1. 实验目的
1. 实现并比较两种调和级数求和方法
2. 量化分析不同求和顺序导致的计算结果差异
3. 理解浮点数舍入误差的累积效应
4. 探究求和顺序对数值计算精度的影响

## 2. 实验原理
### 2.1 调和级数部分和
调和级数的前N项和定义为：

$$ S_N = \sum_{n=1}^{N} \frac{1}{n} $$

### 2.2 两种求和方法
1. 从小到大求和（ $S^{(up)}$）：

$$ S^{(up)} = \sum_{n=1}^{N}\frac{1}{n} = \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{N} $$

2. 从大到小求和（ $S^{(down)}$）：

$$ S^{(down)} = \sum_{n=N}^{1}\frac{1}{n} = \frac{1}{N} + \frac{1}{N-1} + \cdots + \frac{1}{2} + \frac{1}{1} $$

### 2.3 相对差异计算
两种方法的相对差异定义为：

$$ \delta = \frac{|S^{(up)} - S^{(down)}|}{|(S^{(up)} + S^{(down)}) / 2|} $$

## 3. 实验方法
### 3.1 代码实现
- 实现 `sum_up(N)` 函数，从小到大计算调和级数和
- 实现 `sum_down(N)` 函数，从大到小计算调和级数和

### 3.2 数据收集
对不同的N值进行计算：
1. N值选取：使用 `np.logspace(1, 4, 50)` 在对数尺度上均匀取点
2. 计算并记录相对差异

## 4. 实验结果
### 4.1 数据记录

| N     | $S^{(up)}$ | $S^{(down)}$ |  相对差异 δ  |
|---    |------------|--------------|--------------|
|10     | 2.92896825 |  2.92896825  |0.00000000e+00|
|100    |5.18737752  |  5.18737752  |1.71219160e-16|
|1000   |7.48547086  |  7.48547086  |3.55960942e-16|
|10000  |9.78760604  |  9.78760604  |3.81129905e-15|
### 4.2 误差分析图
（在此插入相对差异δ随N变化的双对数图）
![Figure_1](https://github.com/user-attachments/assets/746a17fb-5e22-4169-b736-9f3a96d87693)

## 5. 分析与讨论
### 5.1 结果分析
1. 相对差异随N的变化趋势：
   - （分析图表趋势）
   - 相对差异relative difference总体上随N的增大而增大，但充满着减减增增的波动性
   - 相对差异随着 N 的增大有时增大、有时减小的原因主要是浮点数运算的精度限制和调和级数求和的特性

2. 舍入误差累积效应：
   - （分析为什么 $S^{(down)}$更精确）
   - （结合浮点数表示方式解释）
   - （从大到小求和）通常比（从小到大求和）更精确这主要与浮点数的舍入误差累积效应有关
   - 浮点数的精度是有限的，它只能表示一定范围内的实数，并且存在一定的舍入误差。当进行浮点数加法时，需要先对两个数进行对阶操作，即将它们的指数位调整为相同，然后再进行尾数相加。
   - 从小到大求和时，当累加和变得很大时，再加上一个非常小的项 ，由于浮点数的精度限制，这个小项可能对累加和的影响非常小，以至于在浮点数表示中被舍入掉，从而导致舍入误差的累积；从大到小求和，随着求和的进行，累加和逐渐增大，但此时剩下的项已经相对较大，仍然能够对累加和产生有效的影响，从而减少了舍入误差的累积。

### 5.2 误差来源分析
1. 浮点数表示精度限制：计算机中，浮点数通常使用 IEEE 754 标准来表示。这个标准将浮点数分为符号位、指数位和尾数位。由于尾数位的位数是有限的，这就导致了浮点数只能表示一定范围内的实数，并且存在一定的精度限制。
2. 加法运算中的舍入：进行浮点数加法运算时，由于浮点数的精度限制，会发生舍入误差。在进行加法运算之前，需要对两个数进行对阶操作，即将它们的指数位调整为相同，然后再进行尾数相加。在这个过程中，可能会丢失一些低位的信息，从而导致舍入误差。
3. 求和顺序的影响：从小到大求和，先加较小的数，随着求和的进行，累加和的值不断增大。当累加和变得很大时，再加上一个非常小的项 ，由于浮点数的精度限制，这个小项可能对累加和的影响非常小，以至于在浮点数表示中被舍入掉，从而导致舍入误差的累积。从大到小求和：在这种情况下，先加较大的数，早期的累加和相对较小，此时加上的项相对较大，每个项都能对累加和产生明显的影响，不容易被舍入掉。随着求和的进行，虽然累加和会增大，但剩下的项也相对较大，仍然能够对累加和产生有效的影响，从而减少了舍入误差的累积。

## 6. 结论
（总结实验发现，特别是关于求和顺序对计算精度的影响）
本实验主要围绕调和级数求和展开，分别采用从小到大（sum_up）和从大到小（sum_down）两种不同的求和顺序进行计算，并对比了这两种方法的相对差异。以下是具体的实验发现：1. 浮点数运算的误差累积在计算机中，浮点数的表示存在精度限制，且在加法运算中会产生舍入误差。在计算调和级数的每一项 并累加求和时，这些误差会不断累积，从而影响最终的计算结果。2. 求和顺序对计算精度的影响sum_up（从小到大求和）：该方法在累加过程中，先加较小的数，随着累加和的增大，当加上非常小的项时，由于浮点数精度限制，这些小项可能会被舍入掉，导致舍入误差累积，使得计算结果的精度降低。sum_down（从大到小求和）：此方法先加较大的数，早期累加和相对较小，此时加上的项相对较大，每个项都能对累加和产生明显影响，不容易被舍入掉。随着求和的进行，虽然累加和会增大，但剩下的项也相对较大，能有效减少舍入误差的累积，因此计算结果通常更精确。3. 相对差异的变化趋势通过绘制相对差异随 N 的变化图（plot_differences 函数），可以观察到相对差异随着 N 的增大总体上呈现增大的趋势，但并非单调递增，有时会出现波动。这是因为浮点数运算的不确定性导致舍入误差的累积并非单调的。4. 典型 N 值的计算结果打印典型 N 值的计算结果（print_results 函数），可以直观地看到不同 N 值下两种求和方法的差异，进一步验证了从大到小求和方法的精度更高。

## 7. 思考题
1. 为什么从大到小求和通常能获得更好的精度？
从大到小累加。在求和的早期，累加和相对较小，此时加上的项相对较大，每个项都能对累加和产生明显的影响，不容易在对阶过程中被舍入掉。随着求和的进行，虽然累加和会增大，但剩下的项也相对较大，仍然能够对累加和产生有效的影响，从而减少了舍入误差的累积，因此通常能获得更好的精度。
2. 在实际应用中，如何选择合适的求和策略来减小舍入误差？
数据特点：如果数据中包含大量的小数值，并且最终的和相对较大，那么从大到小求和通常是更好的选择。因为这样可以避免在累加和已经很大时，小数值被舍入掉。例如，在计算多个微小测量值的总和时，采用从大到小的顺序可以减少误差。
数据分布：如果数据的分布比较均匀，没有明显的大小差异，那么求和顺序对精度的影响可能较小。此时可以根据其他因素，如算法的复杂度、代码的可读性等来选择求和顺序。
精度要求：如果对计算结果的精度要求非常高，那么需要更加谨慎地选择求和策略。可以先对数据进行初步的分析，判断数据的特点，然后选择合适的求和顺序。同时，还可以结合其他方法来进一步提高精度
3. 除了改变求和顺序，还有什么方法可以提高数值计算的精度？
使用更高精度的数据类型：在 Python 中，除了使用默认的 float 类型，还可以使用 decimal 模块来进行高精度计算。decimal 模块提供了任意精度的十进制浮点数运算，可以有效避免二进制浮点数运算中的舍入误差。
## 附录：关键代码
```python
# 在此粘贴关键代码实现
```
import numpy as np
import matplotlib.pyplot as plt


def sum_up(N):
    """从小到大计算调和级数和"""
    result = 0.0
    for n in range(1, N + 1):
        result += 1.0 / n
    return result


def sum_down(N):
    """从大到小计算调和级数和"""
    result = 0.0
    for n in range(N, 0, -1):
        result += 1.0 / n
    return result


def calculate_relative_difference(N):
    """计算两种方法的相对差异"""
    s_up = sum_up(N)
    s_down = sum_down(N)
    return abs(s_up - s_down) / abs((s_up + s_down) / 2.0)


def plot_differences():
    """绘制相对差异随N的变化"""
    N_values = np.logspace(1, 4, 50, dtype=int)
    differences = [calculate_relative_difference(N) for N in N_values]

    plt.figure(figsize=(10, 6))
    plt.loglog(N_values, differences, 'o-', alpha=0.7)

    plt.grid(True, which="both", ls="-", alpha=0.2)
    plt.xlabel('N')
    plt.ylabel('Relative Difference')
    plt.title('Relative Difference vs N')

    plt.savefig('harmonic_sum_differences.png', dpi=300, bbox_inches='tight')
    plt.show()


def print_results():
    """打印典型N值的计算结果"""
    N_values = [10, 100, 1000, 10000]

    print("\n计算结果:")
    print("N\tS_up\t\tS_down\t\t相对差异")
    print("-" * 60)

    for N in N_values:
        s_up = sum_up(N)
        s_down = sum_down(N)
        diff = calculate_relative_difference(N)
        print(f"{N}\t{s_up:.8f}\t{s_down:.8f}\t{diff:.8e}")


def main():
    """主函数"""
    # 打印计算结果
    print_results()

    # 绘制误差图
    plot_differences()


if __name__ == "__main__":
    main()

