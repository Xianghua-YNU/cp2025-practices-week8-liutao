# 实验六：球贝塞尔函数的递推关系与数值稳定性实验报告

## 1. 实验目的
1. 实现并比较球贝塞尔函数的向上和向下递推计算方法
2. 理解并掌握向下递推结果的归一化方法
3. 通过实验观察和分析不同递推方法的数值稳定性
4. 深入理解数值计算中的误差放大和抑制机制

## 2. 实验原理
### 2.1 球贝塞尔函数
球贝塞尔函数 $j_l(x)$ 满足二阶线性常微分方程：
$$ x^2 f''(x) + 2xf'(x) + [x^2 - l(l+1)]f(x) = 0 $$

最低阶的两个函数解析形式：
$$ j_0(x) = \frac{\sin x}{x} $$
$$ j_1(x) = \frac{\sin x}{x^2} - \frac{\cos x}{x} $$

### 2.2 递推关系
1. 向上递推：
   $$ j_{l+1}(x) = \frac{2l+1}{x} j_l(x) - j_{l-1}(x) $$

2. 向下递推：
   $$ j_{l-1}(x) = \frac{2l+1}{x} j_l(x) - j_{l+1}(x) $$

### 2.3 归一化方法
向下递推结果的归一化：
$$ j_l^\mathrm{normalized}(x) = j_l^\mathrm{compute}(x) \times \frac{j_0^\mathrm{analytic}(x)}{j_0^\mathrm{compute}(x)} $$

## 3. 实验方法
### 3.1 代码实现
1. `bessel_up(x, lmax)` 函数实现：
   - （描述实现方法）
   - （初始值选取）
   - （递推过程）

2. `bessel_down(x, lmax, m_start)` 函数实现：
   - （描述实现方法）
   - （初始值选取）
   - （递推过程）
   - （归一化方法）

### 3.2 数据收集与处理
1. 测试点选取：x = 0.1, 1.0, 10.0
2. 计算范围：l = 0 到 25
3. 与scipy.special.spherical_jn比较
4. 误差计算方法

## 4. 实验结果
### 4.1 数值结果
| x | l | $j_l^\mathrm{up}(x)$ | $j_l^\mathrm{down}(x)$ | $j_l^\mathrm{scipy}(x)$ |
|---|---|----------------------|------------------------|-------------------------|
|0.1| 3 |      9.518517e-06    |      9.518520e-06      |   9.518520e-06 |
|0.1| 5 |     -1.445698e-08    |      9.616310e-10      |    9.616310e-10|
|0.1| 8 |     -3.306558e-02    |      2.901200e-16      |  2.901200e-16 |
| 1 | 3 |      9.006581e-03    |      9.006581e-03      |   9.006581e-03|
| 1 | 5 |      9.256116e-05    |      9.256116e-05      |  9.256116e-05|
| 1 | 8 |      2.817901e-08    |      2.826499e-08      |  2.826499e-08|
| 10| 3 |     -3.949584e-02    | -3.949585e-02|   -3.949584e-02|
| 10| 5 |     -5.553451e-02    |  -5.553451e-02  | -5.553451e-02|
| 10| 8 |      1.255780e-01    | 1.255780e-01  |  1.255780e-01 |


### 4.2 误差分析图
（在此插入三个x值对应的半对数图）
![Figure](https://github.com/user-attachments/assets/c0b8db90-b108-4f4c-b8fc-6783db41af2a)

## 5. 分析与讨论
### 5.1 数值稳定性分析
1. 向上递推的不稳定性：
   - 失效区域分析（l > x时的表现）：球贝塞尔函数 \(j_l(x)\) 的向上递推公式为：
\(j_{l + 1}(x)=\frac{2l + 1}{x}j_l(x)-j_{l - 1}(x)\)
当 \(l > x\) 时，系数 \(\frac{2l + 1}{x}>1\) 且随着 l 的增大而增大。在递推过程中，由于系数较大，前面阶数的误差会被不断放大，导致计算结果与真实值偏差越来越大，递推公式失效。从物理意义上看，当 l 较大时，球贝塞尔函数的衰减速度很快。而向上递推过程中，由于误差的放大，无法准确捕捉到这种快速衰减的特性。
   - 误差放大机制分析：可以看到，第 l 阶的误差 \(\epsilon_l\) 被系数 \(\frac{2l + 1}{x}\) 放大，并且会传递到后续阶数的计算中，导致误差不断累积和放大
   - 与球诺伊曼函数的关系：球贝塞尔函数 \(j_l(x)\) 和球诺伊曼函数 \(n_l(x)\) 是球贝塞尔方程的两个线性无关解。向上递推公式对于球贝塞尔函数不稳定的原因之一是，在递推过程中，球诺伊曼函数的影响逐渐增大。球诺伊曼函数在 \(x = 0\) 处有奇点，并且在 l 较大时，其增长速度比球贝塞尔函数快。向上递推过程中，由于数值误差的存在，球诺伊曼函数的成分会逐渐混入计算结果中，导致计算结果偏离真实的球贝塞尔函数

2. 向下递推的稳定性：
   - 误差抑制机制：由于球贝塞尔函数 \(j_l(x)\) 随着 l 的增大而迅速衰减，高阶的误差在向低阶传递时，会因为函数值的衰减而被逐渐抑制。也就是说，高阶的小误差对低阶计算结果的影响会越来越小
   - 归一化的作用：在 bessel_down 函数中，我们首先从高阶开始递推，人为设定了初始值 j_temp[m_start+1] = 0.0 和 j_temp[m_start] = 1.0。这样得到的递推结果是一个未归一化的序列。归一化的目的是将递推结果调整到正确的尺度上。我们通过计算解析的 \(j_0(x)\)（代码中 j0_analytic = np.sin(x) / x if x != 0 else 1.0），然后用这个解析值来确定归一化因子 scale = j0_analytic / j_temp[0]，其中 j_temp[0] 是递推得到的未归一化的 \(j_0(x)\) 值。最后将递推得到的所有阶数的球贝塞尔函数值乘以这个归一化因子，就可以得到正确的结
   - 计算精度分析：起始阶数 m_start：起始阶数越大，递推过程中误差的抑制效果越好，但计算量也会相应增加。在代码中，默认的起始阶数是 lmax + 15。如果 m_start 太小，高阶的误差可能无法得到充分抑制，导致低阶的计算结果不准确；如果 m_start 太大，虽然误差抑制效果更好，但会增加不必要的计算量。归一化的准确性：归一化过程中，由于解析的 \(j_0(x)\) 是精确计算的，只要递推过程中误差被有效抑制，归一化后的结果就可以达到较高的精度。

### 5.2 计算效率比较
1. 两种方法的计算时间对比
  运行上述代码后，会输出在不同 x 值下，bessel_up 和 bessel_down 两种方法分别运行 number_of_runs 次的总时间，通过对比这些时间可以直观地看出两种方法的计算效率差异。 
2.影响计算效率的因素分析
   对于 bessel_up 方法
递推次数：递推次数与 lmax 直接相关，lmax 越大，递推次数越多，计算时间越长。因为该方法从低阶向高阶递推，需要进行 lmax - 1 次递推操作。
三角函数计算：计算初始值 j[0] 和 j[1] 时涉及到 np.sin(x) 和 np.cos(x) 的计算，三角函数计算相对耗时，尤其是当 x 的值较为复杂时。
数组操作：初始化长度为 lmax + 1 的数组 j 以及在递推过程中的数组元素赋值操作也会占用一定的时间。
对于 bessel_down 方法
起始阶数 m_start：默认 m_start = lmax + 15，m_start 越大，递推次数越多，计算时间越长。因为该方法从高阶向低阶递推，递推次数为 m_start 次。
临时数组大小：需要初始化长度为 m_start + 2 的临时数组 j_temp，数组越大，内存分配和初始化的时间越长，同时在递推过程中对数组元素的操作也会增加计算量。
归一化操作：计算解析的 j_0(x) 并进行归一化操作，这涉及到三角函数计算和除法运算，会增加额外的计算开销。

## 6. 结论
1. 两种递推方法的适用条件:向上递推方法（bessel_up）
低阶计算：当需要计算的球贝塞尔函数阶数 l 相对较小时，向上递推方法是比较合适的。因为它从低阶开始逐步递推到高阶，在低阶情况下递推次数较少，计算速度较快。
自变量 x 较大：当自变量 x 的值相对较大时，向上递推方法通常能给出较为准确的结果。因为在这种情况下，递推过程中的数值误差不会被显著放大;向下递推方法
高阶计算：对于较高阶的球贝塞尔函数计算，向下递推方法更为适用。它从一个较高的阶数开始向下递推，能够避免向上递推在高阶时可能出现的数值不稳定问题。
自变量 x 较小：当自变量 x 的值较小时，向下递推方法的数值稳定性更好。因为在小 x 情况下，向上递推可能会导致误差的快速积累，而向下递推通过归一化操作可以有效控制误差。
2. 数值稳定性的重要性:避免误差积累：在数值计算中，尤其是涉及到递推计算时，每一步的计算都会引入一定的误差。如果数值不稳定，这些误差会随着递推的进行不断积累，最终导致计算结果与真实值相差甚远。例如，在向上递推计算球贝塞尔函数时，如果阶数较高，误差可能会迅速增大，使得计算结果失去意义。
保证计算结果的可靠性：数值稳定性是保证计算结果可靠性的关键。在科学计算和工程应用中，准确的计算结果至关重要。如果计算结果由于数值不稳定而不准确，可能会导致错误的决策和分析。例如，在物理模拟、信号处理等领域，不准确的计算结果可能会导致模型失效或系统故障。
示例说明：假设我们使用向上递推方法计算高阶球贝塞尔函数，当阶数 l 较大时，误差会不断积累，最终结果可能会出现很大的偏差。而使用向下递推方法，由于其数值稳定性较好，能够得到更可靠的结果
3. 归一化在提高计算精度中的作用:消除初始值的不确定性：在向下递推方法中，我们先假设一个初始值（通常是 j_temp[m_start+1] = 0.0 和 j_temp[m_start] = 1.0），然后进行递推计算。这个初始值是任意设定的，并不一定对应真实的球贝塞尔函数值。通过归一化操作，我们可以根据解析的 j_0(x) 值来调整递推结果，消除初始值的不确定性，从而提高计算精度。
控制误差范围：归一化操作可以将递推过程中产生的误差控制在一定范围内。在递推过程中，由于数值计算的误差，可能会导致结果的数值大小发生变化。通过归一化，我们可以将结果调整到合理的范围内，使得误差不会被无限放大。

## 7. 思考题
1. 为什么向上递推在l > x时会变得不稳定？
在球贝塞尔函数的递推关系中，对于大的 l 值，有不同的渐近行为。当 \(l>x\) 时，球贝塞尔函数随着 l 的增加会迅速衰减。在向上递推过程中，每一步递推都会引入一定的舍入误差。由于数值计算是基于有限精度的浮点数进行的，这些舍入误差会随着递推的进行而不断积累。在 \(l>x\) 的情况下，球贝塞尔函数的值本身很小，而递推公式中的系数 \(\frac{2l + 1}{x}\) 会随着 l 的增大而增大。这使得递推过程中舍入误差的影响被放大，导致计算结果与真实值之间的偏差越来越大，从而使向上递推变得不稳定。
2. 向下递推为什么能够有效抑制误差？
初始条件的选择：在向下递推中，我们通常从一个较高的阶数 \(m_{start}\) 开始，并且可以任意选择初始值 由于球贝塞尔函数对于大的 l 值衰减很快，从高阶开始递推时，即使初始值存在误差，这些误差在递推到低阶时也会被迅速衰减。归一化操作：在递推完成后，我们使用解析解 \(j_0(x)=\frac{\sin(x)}{x}\)（当 \(x\neq0\) 时）或 \(j_0(x) = 1\)（当 \(x = 0\) 时）对结果进行归一化。归一化操作可以消除初始值选择带来的任意性，并且可以将递推过程中积累的误差进行一定程度的修正，从而提高计算结果的精度。
3. 如何选择合适的m_start值以保证计算精度？
\(m_{start}\) 要足够大：\(m_{start}\) 应该足够大，以确保从高阶开始递推时，球贝塞尔函数的值已经衰减到足够小，这样初始值的选择对低阶结果的影响可以忽略不计。通常，一个经验性的选择是 \(m_{start}=l_{max}+15\)，其中 \(l_{max}\) 是我们需要计算的最大阶数。这个选择可以在大多数情况下保证计算精度。根据具体问题进行调整：对于一些特殊的问题，可能需要根据自变量 x 的值和所需的精度进行调整。例如，当 x 较小时，球贝塞尔函数的衰减速度较慢，可能需要更大的 \(m_{start}\) 值；而当 x 较大时，球贝塞尔函数的衰减速度较快，可以适当减小 \(m_{start}\) 值以提高计算效率。
## 附录：关键代码
```python
# 在此粘贴关键代码实现
```
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import spherical_jn


def bessel_up(x, lmax):
    """向上递推计算球贝塞尔函数

    Args:
        x: float, 自变量
        lmax: int, 最大阶数

    Returns:
        numpy.ndarray, 从0到lmax阶的球贝塞尔函数值
    """
    # 初始化结果数组
    j = np.zeros(lmax + 1)

    # 计算初始值
    j[0] = np.sin(x) / x if x != 0 else 1.0  # j_0(x)
    if lmax > 0:
        j[1] = np.sin(x) / x**2 - np.cos(x) / x  # j_1(x)

    # 向上递推
    for l in range(1, lmax):
        j[l+1] = (2*l + 1) / x * j[l] - j[l-1]

    return j


def bessel_down(x, lmax, m_start=None):
    """向下递推计算球贝塞尔函数

    Args:
        x: float, 自变量
        lmax: int, 最大阶数
        m_start: int, 起始阶数，默认为lmax + 15

    Returns:
        numpy.ndarray, 从0到lmax阶的球贝塞尔函数值
    """
    if m_start is None:
        m_start = lmax + 15

    # 初始化临时数组，用于向下递推
    j_temp = np.zeros(m_start + 2)

    # 设置初始值
    j_temp[m_start+1] = 0.0
    j_temp[m_start] = 1.0

    # 向下递推
    for l in range(m_start, 0, -1):
        j_temp[l-1] = (2*l + 1) / x * j_temp[l] - j_temp[l+1]

    # 计算解析的j_0(x)用于归一化
    j0_analytic = np.sin(x) / x if x != 0 else 1.0

    # 归一化
    scale = j0_analytic / j_temp[0]
    j = j_temp[:lmax+1] * scale

    return j


def plot_comparison(x, lmax):
    """绘制不同方法计算结果的比较图

    Args:
        x: float, 自变量
        lmax: int, 最大阶数
    """
    l = np.arange(lmax + 1)

    # 计算三种方法的结果
    j_up = bessel_up(x, lmax)
    j_down = bessel_down(x, lmax)
    j_scipy = spherical_jn(l, x)

    # 绘制函数值的半对数图
    plt.figure(figsize=(10, 5))
    plt.subplot(121)
    plt.semilogy(l, np.abs(j_up), 'o-', label='Up', alpha=0.7)
    plt.semilogy(l, np.abs(j_down), 's--', label='Down', alpha=0.7)
    plt.semilogy(l, np.abs(j_scipy), 'k-', label='Scipy', alpha=0.7)
    plt.grid(True)
    plt.xlabel('l')
    plt.ylabel('|j_l(x)|')
    plt.title(f'x = {x}')
    plt.legend()

    # 绘制相对误差的半对数图
    plt.subplot(122)
    err_up = np.abs((j_up - j_scipy) / j_scipy)
    err_down = np.abs((j_down - j_scipy) / j_scipy)
    plt.semilogy(l, err_up, 'o-', label='Up Error', alpha=0.7)
    plt.semilogy(l, err_down, 's--', label='Down Error', alpha=0.7)
    plt.grid(True)
    plt.xlabel('l')
    plt.ylabel('Relative Error')
    plt.title(f'x = {x}')
    plt.legend()

    plt.tight_layout()
    plt.savefig(f'bessel_x{x}.png', dpi=300, bbox_inches='tight')
    plt.close()


def main():
    """主函数"""
    # 设置参数
    lmax = 25
    x_values = [0.1, 1.0, 10.0]

    # 对每个x值进行计算和绘图
    for x in x_values:
        plot_comparison(x, lmax)

        # 打印特定阶数的结果
        l_check = [3, 5, 8]
        print(f"\nx = {x}:")
        print("l\tUp\t\tDown\t\tScipy")
        print("-" * 50)
        for l in l_check:
            j_up = bessel_up(x, l)[l]
            j_down = bessel_down(x, l)[l]
            j_scipy = spherical_jn(l, x)
            print(f"{l}\t{j_up:.6e}\t{j_down:.6e}\t{j_scipy:.6e}")


if __name__ == "__main__":
    main()
