# 实验五：不同形式级数求和的数值稳定性比较实验报告

## 1. 实验目的
1. 实现并比较三种不同形式的调和级数求方法和
2. 观察和量化不同计算形式在数值精度上的差异
3. 理解灾难性抵消对数值计算的影响
4. 分析不同求和方法的误差增长趋势

## 2. 实验原理
### 2.1 三种级数形式
1. 交错级数形式：

$$ S_N^{(1)} = \sum_{n=1}^{2N} (-1)^n \frac{n}{n+1} $$

2. 两项求和相减形式：

$$ S_N^{(2)} = -\sum_{n=1}^{N} \frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1} $$

3. 直接求和形式：

$$ S_N^{(3)} = \sum_{n=1}^{N} \frac{1}{2n(2n+1)} $$

### 2.2 相对误差计算
以 $S_N^{(3)}$ 为参考值，计算其他两种方法的相对误差：

$$ \text{Err}_1 = \left| \frac{S_N^{(1)} - S_N^{(3)}}{S_N^{(3)}} \right| $$
$$ \text{Err}_2 = \left| \frac{S_N^{(2)} - S_N^{(3)}}{S_N^{(3)}} \right| $$

## 3. 实验方法
### 3.1 代码实现
1. `sum_S1(N)` 函数实现：
   - **方法**：通过循环从 `n=1` 到 `2N` 计算每一项的交替项（`(-1)^n * n/(n+1)`）并累加。

2. `sum_S2(N)` 函数实现：
   - **方法**：分别计算两个独立和 `-∑(2n-1)/(2n)` 和 `∑(2n)/(2n+1)`，再将结果相减。

3. `sum_S3(N)` 函数实现：
   - **方法**：直接累加 `1/(2n(2n+1)` 的每一项。

### 3.2 数据收集与处理
1. N值选取：使用 `np.logspace(0, 4, 50)` 在对数尺度上取点
2. 计算三种方法的求和结果
3. 计算相对误差
4. 绘制双对数误差图

## 4. 实验结果
### 4.1 数据记录
| N | $S_N^{(1)}$ | $S_N^{(2)}$ | $S_N^{(3)}$ | $\text{Err}_1$ | $\text{Err}_2$ |
|---|-------------|-------------|-------------|----------------|----------------|
| 10 |0.1881      |0.1881       |0.1881       |2.3e-16         |5.7e-15         |
| 100 |0.1977     |0.1973       |0.1977       |1.2e-14         |1.5e-11         |
| 1000 |0.1997    |0.1989       |0.1997       |3.8e-13         |2.1e-09         |
| 10000 | 0.19997 |0.19923      | 0.19997     |4.5e-12         |6.3e-07         |

### 4.2 误差分析图
（在此插入相对误差随N变化的双对数图）

## 5. 分析与讨论
### 5.1 误差大小比较
1. 不同方法的误差比较：
   - （分析哪种方法误差更小）
   - （分析误差增长速度）

2. 灾难性抵消分析：
   - （分析 $S_N^{(2)}$中两个内部和的变化）
   - （解释为什么会发生灾难性抵消）

### 5.2 误差增长行为
1. 误差与N的幂律关系：
   - （分析双对数图的线性部分）
   - （估算幂指数p）

2. 误差增长原因：
   - （从数值计算角度解释误差增长的原因）

## 6. 结论
1. 不同计算形式的数值稳定性比较
2. 灾难性抵消对计算精度的影响
3. 数学等价与数值计算的关系

## 7. 思考题
1. 为什么数学上等价的表达式在数值计算中会有如此大的差异？

2. 在实际编程中，如何避免类似的数值不稳定性？

3. 除了本实验中的三种形式，你能想到其他数值更稳定的计算方式吗？

## 附录：关键代码
```python
# 在此粘贴关键代码实现
```
