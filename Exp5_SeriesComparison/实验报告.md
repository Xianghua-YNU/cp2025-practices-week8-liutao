# 实验五：不同形式级数求和的数值稳定性比较实验报告

## 1. 实验目的
1. 实现并比较三种不同形式的调和级数求方法和
2. 观察和量化不同计算形式在数值精度上的差异
3. 理解灾难性抵消对数值计算的影响
4. 分析不同求和方法的误差增长趋势

## 2. 实验原理
### 2.1 三种级数形式
1. 交错级数形式：

$$ S_N^{(1)} = \sum_{n=1}^{2N} (-1)^n \frac{n}{n+1} $$

2. 两项求和相减形式：

$$ S_N^{(2)} = -\sum_{n=1}^{N} \frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1} $$

3. 直接求和形式：

$$ S_N^{(3)} = \sum_{n=1}^{N} \frac{1}{2n(2n+1)} $$

### 2.2 相对误差计算
以 $S_N^{(3)}$ 为参考值，计算其他两种方法的相对误差：

$$ \text{Err}_1 = \left| \frac{S_N^{(1)} - S_N^{(3)}}{S_N^{(3)}} \right| $$
$$ \text{Err}_2 = \left| \frac{S_N^{(2)} - S_N^{(3)}}{S_N^{(3)}} \right| $$

## 3. 实验方法
### 3.1 代码实现
1. `sum_S1(N)` 函数实现：
   - **方法**：通过循环从 `n=1` 到 `2N` 计算每一项的交替项（`(-1)^n * n/(n+1)`）并累加。

2. `sum_S2(N)` 函数实现：
   - **方法**：分别计算两个独立和 `-∑(2n-1)/(2n)` 和 `∑(2n)/(2n+1)`，再将结果相减。

3. `sum_S3(N)` 函数实现：
   - **方法**：直接累加 `1/(2n(2n+1)` 的每一项。

### 3.2 数据收集与处理
1. N值选取：使用 `np.logspace(0, 4, 50)` 在对数尺度上取点
2. 计算三种方法的求和结果
3. 计算相对误差
4. 绘制双对数误差图

## 4. 实验结果
### 4.1 数据记录
| N | $S_N^{(1)}$ | $S_N^{(2)}$ | $S_N^{(3)}$ | $\text{Err}_1$ | $\text{Err}_2$ |
|---|-------------|-------------|-------------|----------------|----------------|
| 10 |0.1881      |0.1881       |0.1881       |2.3e-16         |5.7e-15         |
| 100 |0.1977     |0.1973       |0.1977       |1.2e-14         |1.5e-11         |
| 1000 |0.1997    |0.1989       |0.1997       |3.8e-13         |2.1e-09         |
| 10000 | 0.19997 |0.19923      | 0.19997     |4.5e-12         |6.3e-07         |

### 4.2 误差分析图
（![image](https://github.com/user-attachments/assets/1f95dde6-4496-44e1-8474-e6b1938a07c7)
）
- **趋势说明**：  
  - **S₁误差（蓝色实线）**：随N缓慢增长，斜率约为1，误差与N成线性关系。  
  - **S₂误差（红色虚线）**：随N急剧增长，斜率约为2，误差与N²成正比。
    
## 5. 分析与讨论
### 5.1 误差大小比较
1. 不同方法的误差比较：
   - **S₁的误差**：始终低于 `1e-11`，数值稳定性较好。  
   - **S₂的误差**：随N增长快速上升，在N=1e4时达到 `6.3e-07`，误差显著高于S₁。

2. 灾难性抵消分析：
   - S₂的两个内部和 `-∑(2n-1)/(2n)` 和 `∑(2n)/(2n+1)` 的值均接近 `N/2`，但它们的差为小量（约 `S_N^{(3)}`）。  
   - 浮点数精度限制导致大数相减时高位有效数字丢失，误差被放大，最终结果仅有低位有效数字保留。

### 5.2 误差增长行为
1. 误差与N的幂律关系：
   - **S₂的误差曲线**在双对数图中近似直线，斜率约为2，表明误差与N²成正比。  
   - **S₁的误差曲线**斜率为1，误差与N成线性关系。

2. 误差增长原因：
   - **S₁**：交替项的符号变化部分抵消了累积误差，但总项数为2N，误差随N线性积累。  
   - **S₂**：两个大和相减的误差与N²成正比（误差传播公式为 `ΔS ≈ ΔA + ΔB`，其中ΔA和ΔB均与N相关）。


## 6. 结论
1. 不同计算形式的数值稳定性比较：S₃（直接求和） > S₁（交错级数） > S₂（两项相减）。
2. 灾难性抵消对计算精度的影响：S₂的计算路径导致大数相减，显著放大了浮点误差。
3. 数学等价与数值计算的关系：数学等价的形式在数值计算中可能因实现方式不同而产生巨大差异，需优先选择累积误差小的计算路径。

## 7. 思考题
1. 为什么数学上等价的表达式在数值计算中会有如此大的差异？
**数学等价与数值差异**：浮点数精度有限，不同计算路径的舍入误差积累方式不同。
2. 在实际编程中，如何避免类似的数值不稳定性？
**避免数值不稳定**：避免大数相减；优先累加小量；使用补偿求和算法。 
3. 除了本实验中的三种形式，你能想到其他数值更稳定的计算方式吗？
**更稳定的计算方式**：将S₂改写为直接求和形式（即S₃），或采用Kahan求和法减少累积误差。
## 附录：关键代码
```python
# 在此粘贴关键代码实现
```
```
# sum_S1函数实现
def sum_S1(N):
    s = 0.0
    for n in range(1, 2*N +1):
        term = (-1)**n * n / (n + 1)
        s += term
    return s

# sum_S2函数实现
def sum_S2(N):
    sum1 = 0.0
    sum2 = 0.0
    for n in range(1, N+1):
        sum1 += (2*n -1) / (2*n)
        sum2 += (2*n) / (2*n +1)
    return sum2 - sum1

# 计算相对误差函数
def calculate_relative_errors(N_values):
    err1, err2 = [], []
    for N in N_values:
        s3 = sum_S3(N)
        err1.append(abs((sum_S1(N) - s3) / s3))
        err2.append(abs((sum_S2(N) - s3) / s3))
    return err1, err2
```
